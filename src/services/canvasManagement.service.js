import { 
  collection, 
  doc, 
  addDoc, 
  updateDoc, 
  deleteDoc,
  getDocs,
  getDoc,
  setDoc,
  query,
  where,
  arrayUnion,
  serverTimestamp
} from 'firebase/firestore'
import { db } from './firebase.js'
import { FIREBASE_COLLECTIONS } from '../constants/canvas.constants.js'
import { canUserAccessProject } from './project.service.js'

/**
 * Canvas Management Service
 * 
 * Handles canvas lifecycle management and project integration.
 * Extracted from canvas.service.js to improve modularity.
 */

/**
 * Creates a new canvas with auto-generated matching project
 * @param {string} name - Canvas name
 * @param {string} userId - User ID creating the canvas
 * @returns {Object} - Result object with success status and canvas data
 */
export const createCanvas = async (name, userId) => {
  try {
    // Validate input
    if (!name || typeof name !== 'string' || name.trim().length === 0) {
      return { success: false, error: 'Canvas name is required' };
    }
    
    if (!userId || typeof userId !== 'string') {
      return { success: false, error: 'User ID is required' };
    }

    const sanitizedName = name.trim().substring(0, 100);

    // First create the canvas document to get its ID
    const canvasData = {
      projectId: '', // Will be set to canvasId
      name: sanitizedName,
      ownerId: userId,
      createdBy: userId,
      collaborators: [], // Initialize empty collaborators array
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    };

    const canvasesCollection = collection(db, 'canvases');
    const canvasRef = await addDoc(canvasesCollection, canvasData);
    const canvasId = canvasRef.id;

    // Create auto-generated project with projectId = canvasId
    const projectData = {
      name: sanitizedName,
      ownerId: userId,
      collaborators: [],
      autoGenerated: true,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    };

    const projectRef = doc(db, 'projects', canvasId);
    await updateDoc(canvasRef, { projectId: canvasId });
    
    // Create the project document with the same ID
    await setDoc(projectRef, projectData);
    
    return { 
      success: true, 
      canvasId: canvasId, 
      canvas: { id: canvasId, ...canvasData, projectId: canvasId }
    };
  } catch (error) {
    console.error('Error creating canvas:', error);
    return { success: false, error: 'Failed to create canvas' };
  }
};

/**
 * Gets all canvases for a user (owned and collaborated)
 * @param {string} userId - User ID requesting the canvases
 * @returns {Object} - Result object with success status and canvases array
 */
export const getCanvasesForUser = async (userId) => {
  try {
    if (!userId) {
      return { success: false, error: 'User ID is required' };
    }

    // Query for canvases where user is the owner
    const ownedCanvasesQuery = query(
      collection(db, 'canvases'),
      where('ownerId', '==', userId)
    );

    // Query for canvases where user is in collaborators array
    const collaboratedCanvasesQuery = query(
      collection(db, 'canvases'),
      where('collaborators', 'array-contains', userId)
    );

    const [ownedSnapshot, collaboratedSnapshot] = await Promise.all([
      getDocs(ownedCanvasesQuery),
      getDocs(collaboratedCanvasesQuery)
    ]);

    // Merge and deduplicate
    const canvasMap = new Map();
    
    ownedSnapshot.forEach((doc) => {
      canvasMap.set(doc.id, { id: doc.id, ...doc.data() });
    });
    
    collaboratedSnapshot.forEach((doc) => {
      if (!canvasMap.has(doc.id)) {
        canvasMap.set(doc.id, { id: doc.id, ...doc.data() });
      }
    });

    // Convert to array and sort alphabetically
    const canvases = Array.from(canvasMap.values()).sort((a, b) => 
      (a.name || '').localeCompare(b.name || '')
    );

    return { success: true, canvases };
  } catch (error) {
    console.error('Error getting canvases for user:', error);
    return { success: false, error: 'Failed to fetch canvases' };
  }
};

/**
 * Gets a single canvas by ID
 * @param {string} canvasId - Canvas ID
 * @param {string} userId - User ID requesting the canvas
 * @returns {Object} - Result object with success status and canvas data
 */
export const getCanvas = async (canvasId, userId) => {
  try {
    if (!canvasId || !userId) {
      return { success: false, error: 'Canvas ID and user ID are required' };
    }

    const canvasRef = doc(db, 'canvases', canvasId);
    const canvasSnap = await getDoc(canvasRef);

    if (!canvasSnap.exists()) {
      return { success: false, error: 'Canvas not found' };
    }

    const canvas = { id: canvasSnap.id, ...canvasSnap.data() };

    // Check if user has access to the canvas's project
    const accessCheck = await canUserAccessProject(canvas.projectId, userId);
    if (!accessCheck.success || !accessCheck.canAccess) {
      return { success: false, error: 'User does not have access to this canvas' };
    }

    return { success: true, canvas };
  } catch (error) {
    console.error('Error getting canvas:', error);
    return { success: false, error: 'Failed to fetch canvas' };
  }
};

/**
 * Updates canvas details
 * @param {string} canvasId - Canvas ID
 * @param {Object} updates - Object containing fields to update
 * @param {string} userId - User ID making the request
 * @returns {Object} - Result object with success status
 */
export const updateCanvas = async (canvasId, updates, userId) => {
  try {
    if (!canvasId || !userId) {
      return { success: false, error: 'Canvas ID and user ID are required' };
    }

    // Get canvas to check project access
    const canvas = await getCanvas(canvasId, userId);
    if (!canvas.success) {
      return canvas;
    }

    // Check if user has access to modify (must have project access)
    const accessCheck = await canUserAccessProject(canvas.canvas.projectId, userId);
    if (!accessCheck.success || !accessCheck.canAccess) {
      return { success: false, error: 'User does not have permission to update this canvas' };
    }

    // Sanitize updates (only allow certain fields)
    const allowedFields = ['name'];
    const sanitizedUpdates = {};
    
    for (const [key, value] of Object.entries(updates)) {
      if (allowedFields.includes(key)) {
        if (key === 'name' && value) {
          sanitizedUpdates.name = String(value).trim().substring(0, 100);
        }
      }
    }

    if (Object.keys(sanitizedUpdates).length === 0) {
      return { success: false, error: 'No valid fields to update' };
    }

    sanitizedUpdates.updatedAt = serverTimestamp();

    const canvasRef = doc(db, 'canvases', canvasId);
    await updateDoc(canvasRef, sanitizedUpdates);

    return { success: true };
  } catch (error) {
    console.error('Error updating canvas:', error);
    return { success: false, error: 'Failed to update canvas' };
  }
};

/**
 * Deletes a canvas, its matching project, and all its objects
 * @param {string} canvasId - Canvas ID
 * @param {string} userId - User ID making the request
 * @returns {Object} - Result object with success status
 */
export const deleteCanvas = async (canvasId, userId) => {
  try {
    if (!canvasId || !userId) {
      return { success: false, error: 'Canvas ID and user ID are required' };
    }

    // Get canvas to check ownership
    const canvasRef = doc(db, 'canvases', canvasId);
    const canvasSnap = await getDoc(canvasRef);

    if (!canvasSnap.exists()) {
      return { success: false, error: 'Canvas not found' };
    }

    const canvas = canvasSnap.data();

    // Only canvas owner can delete canvas
    if (canvas.ownerId !== userId) {
      return { success: false, error: 'Only canvas owner can delete canvas' };
    }

    // Delete all objects in the canvas first
    const objectsQuery = query(
      collection(db, FIREBASE_COLLECTIONS.CANVAS_OBJECTS),
      where('canvasId', '==', canvasId)
    );
    
    const objectsSnapshot = await getDocs(objectsQuery);
    const deletePromises = [];
    
    objectsSnapshot.forEach((doc) => {
      deletePromises.push(deleteDoc(doc.ref));
    });
    
    // Delete the matching project document (projectId = canvasId)
    const projectRef = doc(db, 'projects', canvasId);
    deletePromises.push(deleteDoc(projectRef));

    // Delete the canvas
    deletePromises.push(deleteDoc(canvasRef));

    await Promise.all(deletePromises);

    return { success: true };
  } catch (error) {
    console.error('Error deleting canvas:', error);
    return { success: false, error: 'Failed to delete canvas' };
  }
};

/**
 * Add a collaborator to a canvas by email
 * @param {string} canvasId - Canvas ID
 * @param {string} inviteeEmail - Email of user to invite
 * @param {string} inviterUserId - User ID of person sending invite
 * @returns {Object} - Result with success, pending, and message fields
 */
export const addCollaboratorToCanvas = async (canvasId, inviteeEmail, inviterUserId) => {
  try {
    if (!canvasId || !inviteeEmail || !inviterUserId) {
      return { success: false, pending: false, message: 'Canvas ID, email, and inviter ID are required' };
    }

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(inviteeEmail)) {
      return { success: false, pending: false, message: 'Invalid email format' };
    }

    // Get canvas to verify inviter has access
    const canvasRef = doc(db, 'canvases', canvasId);
    const canvasSnap = await getDoc(canvasRef);

    if (!canvasSnap.exists()) {
      return { success: false, pending: false, message: 'Canvas not found' };
    }

    const canvas = canvasSnap.data();

    // Verify inviter is owner or collaborator
    if (canvas.ownerId !== inviterUserId && 
        !(canvas.collaborators || []).includes(inviterUserId)) {
      return { success: false, pending: false, message: 'You do not have permission to invite to this canvas' };
    }

    // Get inviter info for pending invites
    const inviterRef = doc(db, 'users', inviterUserId);
    const inviterSnap = await getDoc(inviterRef);
    const inviterEmail = inviterSnap.exists() ? inviterSnap.data().email : 'unknown';

    // Check if user is inviting themselves
    if (inviteeEmail.toLowerCase() === inviterEmail.toLowerCase()) {
      return { success: false, pending: false, message: 'You cannot invite yourself' };
    }

    // Look up user by email in users collection
    const usersQuery = query(
      collection(db, 'users'),
      where('email', '==', inviteeEmail.toLowerCase())
    );

    const usersSnapshot = await getDocs(usersQuery);

    if (!usersSnapshot.empty) {
      // User exists - add to collaborators immediately
      const inviteeDoc = usersSnapshot.docs[0];
      const inviteeUserId = inviteeDoc.id;

      // Check if already a collaborator or owner
      if (canvas.ownerId === inviteeUserId) {
        return { success: false, pending: false, message: 'User is already the canvas owner' };
      }

      if ((canvas.collaborators || []).includes(inviteeUserId)) {
        return { success: false, pending: false, message: 'User is already a collaborator' };
      }

      // Add to canvas collaborators
      await updateDoc(canvasRef, {
        collaborators: arrayUnion(inviteeUserId),
        updatedAt: serverTimestamp()
      });

      // Add to project collaborators (projectId = canvasId)
      const projectRef = doc(db, 'projects', canvasId);
      await updateDoc(projectRef, {
        collaborators: arrayUnion(inviteeUserId),
        updatedAt: serverTimestamp()
      });

      console.log('Collaborator added successfully:', inviteeEmail);
      return { success: true, pending: false, message: 'Collaborator added successfully' };
    } else {
      // User doesn't exist - create pending invite
      const inviteData = {
        canvasId,
        canvasName: canvas.name,
        inviteeEmail: inviteeEmail.toLowerCase(),
        invitedBy: inviterUserId,
        invitedByEmail: inviterEmail,
        createdAt: serverTimestamp(),
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days from now
      };

      await addDoc(collection(db, 'pendingInvites'), inviteData);

      console.log('Pending invite created for:', inviteeEmail);
      // TODO: Send email notification to inviteeEmail
      console.log('TODO: Send email to', inviteeEmail, 'about canvas invitation');
      
      return { success: true, pending: true, message: 'Invitation sent. User will be added when they sign up.' };
    }
  } catch (error) {
    console.error('Error adding collaborator:', error);
    
    // Provide more specific error messages
    if (error.code === 'permission-denied' || error.message?.includes('permission')) {
      return { success: false, pending: false, message: 'Permission denied. Please check Firestore security rules.' };
    } else if (error.code === 'not-found') {
      return { success: false, pending: false, message: 'Canvas not found.' };
    } else {
      return { success: false, pending: false, message: 'Failed to add collaborator. Please try again.' };
    }
  }
};
